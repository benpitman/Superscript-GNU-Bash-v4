#!/bin/bash +m

: <<'Superscript_Doc'
    @Param      bool    1
        True if script is to be run in terminal mode
    @Param      bool    2
        True if script is to be run in debug mode
Superscript_Doc

[ -z "$1" ] && exit 1

# If game is loaded on a terminal outside of a GUI environment
if $1; then
    in_tty=false
else
    if ( [ -z "$DISPLAY" ] || [[ "$TERM" == "linux" ]] ); then
        in_cli=true
    else
        in_cli=false
    fi
    in_tty=true
fi

log_dir=/var/games/superscript
# Debug mode sends STDERR to an error file
if $2; then
    export PS4='+(${LINENO}) ${FUNCNAME[0]}(): '
    set -x
    exec 2>$log_dir/debug.log
else
    exec 2>$log_dir/error.log
fi

Cleanup() {
    [ -s "$hs_log" ] || rm "$hs_log"
    tput cvvis
    stty echo
    # Go to bottom right corner and print a new line
    tput cup 39 49
    echo
}
trap Cleanup EXIT

Load_Sprites() {
    sprite['ship']='\e[1m\u23c5\e[0m'       # ⏅
    sprite['projectile']='\u0027'           # '
    sprite['enemy1']='\e[1m\u25bf\e[0m'     # ▿
    sprite['enemy2']='\u2352'               # ⍒
    sprite['enemy3']='\u236b'               # ⍫
    sprite['boss1']='\e[1m\u2362\e[0m'      # ⍢
    sprite['boss2']='\e[1m\u2354\e[0m'      # ⍔
    sprite['explosion1']='\u2058'           # ⁘
    sprite['explosion2']='\u205b'           # ⁛
    sprite['wall1']='\u2582'                # 1/4
    sprite['wall2']='\u2584'                # 1/2
    sprite['wall3']='\u2586'                # 3/4
    sprite['wall4']='\u2588'                # Full
}

Game_Over() {
    local               \
        dw              \
        editable_index  \
        editable_row    \
        end_choose=0    \
        end_game        \
        ln              \
        next_score      \
        num_scores      \
        playername      \
        score_row       \
        score_shown     \
        usernames=()    \
        userscores=()

    # Destroy player then all remaining enemies
    Destroy_Entity -1 true
    while (( ${#words[@]} )); do
        Destroy_Entity 0 true
        sleep 0.1
    done

    # Iterate through any standing walls and destroy them
    for (( dw = 0; dw < 47; dw++ )); do
        if (( ${wall_log[$dw]} > 0 )); then
            Destroy_Wall $(( $dw + 1 ))
            Score_Modifier true $(( ${wall_log[$dw]} * 10 ))
        fi
        sleep 0.02
    done

    Clear_Map 38
    tput cup 3 19
    printf '\e[1mHIGHSCORES\e[0m'

    tput cup 5 $(( 24 - (${#hs_name} / 2) ))
    printf "$hs_name"

    score_shown=false
    num_scores=$( wc -l < "$hs_log" )
    for (( ln = 0; ln <= $num_scores; ln++ )); do
        score_ln=$( sed -n "$(( $ln + 1 ))p" "$hs_log" )
        userscores[$ln]=${score_ln/*\,/}
        usernames[$ln]=${score_ln/\,*/}
        if ! $score_shown && ( (( $num_scores == 0 )) || \
                (( ${userscores[$ln]} <= $score )) || \
                (( $ln == $num_scores )) ); then
            score_shown=true
            editable_index=$ln
        fi
    done

    # Insert current score into the arrays
    usernames=(
        ${usernames[@]:0:$editable_index}
        ""
        ${usernames[@]:$editable_index}
    )
    userscores=(
        ${userscores[@]:0:$editable_index}
        $score
        ${userscores[@]:$editable_index}
    )

    score_row=8
    for (( next_score = 0; next_score < ${#userscores[@]}; next_score++ )); do
        tput cup $score_row 6
        if (( $next_score < 20 )); then
            (( $next_score == $editable_index )) && editable_row=$score_row
            Print_Score $score_row $(( $next_score + 1 )) \
                "${usernames[$next_score]}" ${userscores[$next_score]}
        elif (( $editable_index > 19 )); then
            editable_row=30
            printf '\e[1m'
            Print_Score $editable_row $(( $editable_index + 1 )) "" $score
            break
        else
            break
        fi
        (( score_row++ ))
    done

    Text_Entry $editable_row 9 8 "." "playername"

    # Add the new score to the highscores file
    if (( $editable_index == $num_scores )); then
        printf "$playername,$score\n" >> "$hs_log"
    else
        sed -i "$(( $editable_index + 1 ))s/^/$playername\,$score\n/" "$hs_log"
    fi

    while true; do
        end_game=(
            'REPLAY'
            'MAIN MENU'
            'QUIT'
        )
        end_game[$end_choose]="\e[7m${end_game[$end_choose]}\e[0m"
        tput cup 34 16
        printf "${end_game[0]}  ${end_game[1]}"
        tput cup 36 22
        printf "${end_game[2]}"

        IFS= read -rsn1 key1
        read -rsn1 -t0.0001 key2
        read -rsn1 -t0.0001 key3

        case $key3 in
            [CD])   (( $end_choose < 2 )) && (( end_choose ^= 1 ));;
            "B")    if (( $end_choose < 2 )); then
                        prev_end=$end_choose
                        end_choose=2
                    fi;;
            "A")    (( $end_choose == 2 )) && end_choose=$prev_end;;
        esac

        if [ -z "$key1" ]; then
            case $end_choose in
                0)  return 2;;
                1)  return 3;;
                2)  exit;;
            esac
        fi
        unset key1 key2 key3
    done
}

Destroy_Wall() {
    tput cup 36 $1
    printf "${sprite[explosion2]}"
    sleep 0.05
    printf "\b "
}

: <<'Destroy_Entity_Doc'
    @Param      int     1
        Index of enemy to be removed
        -1 if player
    @Param      bool    2
        True if explosion is required
Destroy_Entity_Doc

Destroy_Entity() {
    local d_col d_row
    if (( $1 > -1 )); then
        if (( ${enemy_row[$1]} < $player_row )); then
            tput cup ${enemy_row[$1]} ${word_col[$1]}
            printf "%$(( ${#words[$1]} + 2 ))s"
        fi
        d_row=${enemy_row[$1]}
        d_col=${enemy_col[$1]}
    else
        d_row=$player_row
        d_col=$player_col
    fi
    tput cup $d_row $d_col

    if $2; then
        printf "${sprite[explosion1]}"
        sleep 0.05
        printf "\b${sprite[explosion2]}"
        sleep 0.05
        printf "\b "
    else
        printf " "
    fi
    if (( $1 > -1 )); then
        if [ -n "$word_focus" ]; then
            # If targeted word is deleted, unset associated variables
            if (( $1 == $word_focus )); then
                unset match stun word_focus
            # Otherwise reassign the target to the index of the previous word
            else
                (( word_focus-- ))
            fi
        fi
        # Remove entity from all arrays
        words=( ${words[@]:0:$1} ${words[@]:$(( $1 + 1 ))} )
        word_col=( ${word_col[@]:0:$1} ${word_col[@]:$(( $1 + 1 ))} )
        enemy_row=( ${enemy_row[@]:0:$1} ${enemy_row[@]:$(( $1 + 1 ))} )
        enemy_col=( ${enemy_col[@]:0:$1} ${enemy_col[@]:$(( $1 + 1 ))} )
        enemies=( ${enemies[@]:0:$1} ${enemies[@]:$(( $1 + 1 ))} )
        print_left=( ${print_left[@]:0:$1} ${print_left[@]:$(( $1 + 1 ))} )
    fi
}

: <<'Score_Modifier_Doc'
    @Param      bool    1
        If true, increase the score
        If false, reset the progress bar to zero
Score_Modifier_Doc

Score_Modifier() {
    local               \
        score_col       \
        score_equation  \
        score_index
    if $1; then
        # If progress bar is full, reset it and increase multiplier and colour
        if (( $progress_bar == 43 )); then
            if (( $colour < 7 )); then
                (( colour++ ))
                progress_bar=0
            fi
            (( score_mult++ ))
        fi
        (( progress_bar++ ))
        (( overall_progress++ ))
        if [ -z "$2" ]; then
            score_equation="$score + ($overall_progress * $score_mult)"
        else
            score_equation="$score + $2"
        fi
        if hash bc 2>/dev/null; then
            # bc is used in case the score gets higher than a 64 bit integer
            read score <<< "$( bc <<< "$score_equation" )"
        # Fallback if bc is not installed
        else
            (( score = ($score_equation) ))
        fi
    else
        progress_bar=0
        overall_progress=0
        colour=1
        score_mult=1
    fi
    score_index=0
    tput cup 38 1
    # Draw the progress bar
    for score_col in {1..43}; do
        if (( ($score_col - 1) < $progress_bar )); then
            printf "${score_colours[$colour]}"
            if (( $score_col > (21 - (${#score} / 2)) && $score_index < ${#score} )); then
                printf "${score:$score_index:1}"
                (( score_index++ ))
            else
                printf "─"
            fi
        else
            printf "${score_colours[$(( colour - 1 ))]}"
            if (( $score_col > (21 - (${#score} / 2)) && $score_index < ${#score} )); then
                printf "\e[24m${score:$score_index:1}"
                (( score_index++ ))
            else
                if (( $colour == 1 )); then
                    printf " "
                else
                    printf "─"
                fi
            fi
        fi
    done
    tput sgr0
    (( $score_mult > 1 )) && printf '%3sx' "$score_mult" || printf "    "
}

: <<'Shoot_Doc'
    @Param      bool    1
        If true, reposition player
Shoot_Doc

Shoot() {
    local p
    Score_Modifier true
    if $1; then
        tput cup $player_row $player_col
        printf " "
        if (( ${print_left[$2]} )); then
            player_col=${enemy_col[$2]}
        else
            player_col=${word_col[$2]}
        fi
        tput cup $player_row $player_col
        printf "${sprite[ship]}"
    fi
    tput cup 34 $player_col
    printf "${sprite[projectile]}"
    for (( p = 33; p > ${enemy_row[$2]}; p-- )); do
        tput cup $p $player_col
        printf "${sprite[projectile]}"
        tput cup $(( $p + 1 )) $player_col
        printf " "
        sleep 0.001
    done
    tput cup $(( $p + 1 )) $player_col
    printf " "
    Draw_Target
    if (( $match == ${#words[$word_focus]} )); then
        Destroy_Entity $word_focus true
    fi
}

: <<'Target_Doc'
    @Param      int    1
        Position of the targeted word
Target_Doc

Target() {
    (( word_focus = (${#words[@]} - 1) ))

    # Move focussed word to the end of all arays
    words=( ${words[@]:0:$1} ${words[@]:$(( $1 + 1 ))} ${words[$1]} )
    word_col=( ${word_col[@]:0:$1} ${word_col[@]:$(( $1 + 1 ))} ${word_col[$1]} )
    enemy_row=( ${enemy_row[@]:0:$1} ${enemy_row[@]:$(( $1 + 1 ))} ${enemy_row[$1]} )
    enemy_col=( ${enemy_col[@]:0:$1} ${enemy_col[@]:$(( $1 + 1 ))} ${enemy_col[$1]} )
    enemies=( ${enemies[@]:0:$1} ${enemies[@]:$(( $1 + 1 ))} ${enemies[$1]} )
    print_left=( ${print_left[@]:0:$1} ${print_left[@]:$(( $1 + 1 ))} ${print_left[$1]} )
}

Draw_Target() {
    local word_len=${#words[$word_focus]}

    # Set word with matched characters in green
    word="\e[32;1m${words[$word_focus]:0:$match}\e[39m${words[$word_focus]:$match}\e[0m"

    if (( ${enemy_row[$word_focus]} == $player_row )); then
        # Disallow printing of the word on the same row as the player
        unset word
        # Align to ship ..
        tput cup ${enemy_row[$word_focus]} ${enemy_col[$word_focus]}
    else
        # .. else align to word
        tput cup ${enemy_row[$word_focus]} ${word_col[$word_focus]}
    fi

    # Re-print the targeted word and enemy
    if (( ${print_left[$word_focus]} )); then
        [ -n "$word" ] && printf "$word "
        printf "${enemies[$word_focus]}"
    else
        printf "${enemies[$word_focus]}"
        [ -n "$word" ] && printf " $word"
    fi
}

Draw_All() {
    local               \
        next_row        \
        wall_capacity   \
        wall_col        \
        wall_ind        \
        wall_kill       \
        word            \
        word_len

    if [ -n "$word_focus" ]; then
        tput cup ${enemy_row[$word_focus]} ${word_col[$word_focus]}
        printf "%$(( ${#words[$word_focus]} + 2 ))s"
    fi
    for (( l = 0; l < ${#words[@]}; l++ )); do

        # Save word length to avoid accessing array
        word_len=${#words[$l]}


        # If word is between 10 and 12 letters long
        if (( $word_len > 9 && $word_len < 13 && (( ($RANDOM % 3) == 0 )); then
            # If all enemies are on the screen, load allies randomly
            if [ -n "$word_focus" ] && (( ${enemy_row[-2]} > 1 )) || \
                    (( ${enemy_row[-1]} > 1 )); then
                # Load a new enemy 2 characters long
                Load_Enemies true 2
            # If word is greater than 12 letters long
            elif (( $word_len > 12 )); then
                Load_Enemies true 4
            fi
        fi

        # Predict next row unless the enemy has been stunned
        if [ -n "$stun" ] && (( $l == $stun )); then
            unset stun
            next_row=${enemy_row[$l]}
        else
            (( next_row = (${enemy_row[$l]} + 1) ))
        fi

        # If entity is not on the screen, go to next loop
        if (( $next_row < 1 )); then
            enemy_row[$l]=$next_row
            continue
        fi

        # If an enemy passes through the wall, game over
        if (( $next_row == 37 )); then
            Destroy_Entity $l false
            Game_Over
            return $?
        fi

        # If an enemy collides with the player, game over
        if (( $next_row == $player_row && ${enemy_col[$l]} == $player_col )); then
            # Destroy the colliding enemy, only explosion needed
            Destroy_Entity $l true
            Game_Over
            return $?
        fi

        if (( $next_row > 35 )); then
            wall_col=${enemy_col[$l]}
            # Wall starts at column 1, so deduct one for zero start array
            (( wall_ind = ($wall_col - 1) ))
            wall_capacity=${wall_log[$wall_ind]}
            if (( $wall_capacity > 0 )); then
                # Destroy fraction of the wall dependent on word length
                if (( $word_len < 13 )); then
                    (( wall_kill = (($word_len + 2) / 3) ))
                else
                    wall_kill=4
                fi
                (( wall_capacity -= $wall_kill ))
                wall_log[$wall_ind]=$wall_capacity
                # If a wall has been damaged enough, destroy it
                if (( $wall_capacity < 1 )); then
                    Destroy_Wall $wall_col
                # Else redraw it
                else
                    tput cup 36 $wall_col
                    printf "${sprite[wall$wall_capacity]}"
                fi
                Destroy_Entity $l true
                # Compensate for missing word
                (( l-- ))
                continue
            else
                tput cup ${enemy_row[$l]} ${enemy_col[$l]}
                printf " "
            fi
        fi

        # Update saved positions
        enemy_row[$l]=$next_row

        # If targeted, draw separately
        if [ -n "$word_focus" ] && (( $l == $word_focus )); then
            Draw_Target
            return
        else
            # Set the printable word
            word=${words[$l]}
        fi

        if (( $next_row > 1 && $next_row < 36 )) ; then
            tput cup $(( ${enemy_row[$l]} - 1 )) ${word_col[$l]}
            printf "%$(( $word_len + 2 ))s"
        fi

        if (( $next_row > 34 )); then
            # Disallow printing of the word on the same row as the player
            unset word
            # Align to ship ..
            tput cup $next_row ${enemy_col[$l]}
        else
            # .. otherwise align to word
            tput cup $next_row ${word_col[$l]}
        fi

        # Print word and enemy in correct order
        if (( ${print_left[$l]} )); then
            [ -n "$word" ] && printf "$word "
            printf "${enemies[$l]}"
        else
            printf "${enemies[$l]}"
            [ -n "$word" ] && printf " $word"
        fi
    done
}

Set_Default_Text() {
    local                                           \
        cent                                        \
        choose                                      \
        new_word                                    \
        num_allies=$( ls $lib_dir/allies | wc -l )  \
        num_file_lines                              \
        offset=$(( $level + 3 ))                    \
        r_index                                     \
        r_total=0                                   \
        r_seq_total=0                               \
        rarity=()                                   \
        random_cent                                 \
        random_line                                 \
        word_file                                   \
        word_limit=$(( $level + 4 ))

    # Dissipate a percentage chance over the word files from high to low
    for (( i = $offset; i > ($offset - $num_allies); i--)); do
        if (( $i > 0 )); then
            rarity+=( $(( ((i * 100) / $offset) )) )
            (( r_total += ${rarity[@]: -1} ))
        else
            rarity+=( 0 )
        fi
    done

    # Ratio all percentages under their total
    for (( r_index = 0; r_index < ${#rarity[@]}; r_index++ )); do
        if (( ${rarity[$r_index]} > 0 )); then
            (( cent = ((${rarity[r_index]} * 100) / $r_total) ))
            (( rarity[$r_index] = ($cent + $r_seq_total) ))
            (( r_seq_total += $cent ))
        fi
    done

    # Add new words based on their percentage likelihood
    for (( new_word = 0; new_word < $word_limit; new_word++ )); do
        (( random_cent = (($RANDOM % $r_seq_total) + 1) ))
        for (( choose = 0; choose < ${#rarity[@]}; choose++ )); do
            if (( $random_cent < ${rarity[choose]} )); then
                word_file="$lib_dir/allies/$(( $choose + 2 ))_letters.txt"
                break
            fi
        done
        num_file_lines=$( wc -l < "$word_file" )
        (( random_line = (($RANDOM % $num_file_lines ) + 1) ))
        word_to_add=$( sed -n "${random_line}p" < "$word_file" )
        first_letter=${word_to_add:0:1}
        [[ " ${first_letters[@],,} " =~ " ${first_letter,} " ]] && continue
        first_letters+=( $first_letter )
        prov_words+=( $word_to_add )
    done
}

: <<'Load_Enemies_Doc'
    @Param      bool    1
        True if only loading one new enemy
    @Param      int     2
        Length of new enemy
Load_Enemies_Doc

Load_Enemies() {
    local                   \
        e_col               \
        e_row               \
        first_letter        \
        first_letters=()    \
        line_max            \
        prov_words          \
        word_len            \
        word_to_add

    # Add new enemies up to 47 (playable screen width)
    if $1; then
        if (( ${#enemies[@]} < 47 )); then
            (( ally_len = (($RANDOM % $2) + 2) ))
            line_max=$( wc -l < "$lib_dir/allies/${ally_len}_letters.txt" )
            word_to_add=$( sed -n "$(( ($RANDOM % $line_max) + 1 ))p" \
                "$lib_dir/allies/${ally_len}_letters.txt" )
            first_letter=${word_to_add:0:1}
            [[ " ${first_letters[@],,} " =~ " ${first_letter,} " ]] && continue
            first_letters+=( $first_letter )
            prov_words=( $word_to_add )
        else
            return
        fi
    else
        enemy_col=()
        if [ -s "$text_file" ]; then
            prov_words=( $( sed -n "${level}p" "$text_file" ) )
            if (( ${#prov_words[@]} == 0 )); then
                Game_Over
                return $?
            fi
        else
            Set_Default_Text
        fi
        if (( ${#prov_words} > 47 )); then
            # Remove all words after index 46
            eval unset prov_words[{47..${#prov_words[@]}}]
        fi
    fi

    for (( i = 0, e_row = 0; i < ${#prov_words[@]}; i++, e_row-- )); do
        word_len=${#prov_words[$i]}
        # If word is longer than 20 characters, delete it and move on
        if (( $word_len > 20 )); then
            prov_words=( ${prov_words[@]:0:$i} ${prov_words[@]:$(( $i + 1 ))} )
            continue
        fi

        while (( e_col = (($RANDOM % 46) + 1) )); do
            [[ " ${enemy_col[@]} " =~ " $e_col " ]] || break
        done
        # If word bleeds over the border, set printing before the ship
        if (( $word_len > (46 - $e_col) )); then
            word_col+=( $(( $e_col - ($word_len + 1) )) )
            print_left+=( 1 )
        else
            word_col+=( $e_col )
            print_left+=( 0 )
        fi
        # Coordinates for ship
        enemy_col+=( $e_col )
        enemy_row+=( $e_row )

        if (( $word_len < 4 )); then
            enemies+=( "${sprite[enemy1]}" )
        elif (( $word_len < 7 )); then
            enemies+=( "${sprite[enemy2]}" )
        elif (( $word_len < 10 )); then
            enemies+=( "${sprite[enemy3]}" )
        elif (( $word_len < 13 )); then
            enemies+=( "${sprite[boss1]}" )
        elif (( $word_len > 12 )); then
            enemies+=( "${sprite[boss2]}" )
        fi
        words+=( "${prov_words[$i]}" )
    done

    if $1; then
        # If new words have been added, retarget the focussed word if there is one
        if [ -n $word_focus ] && (( $word_focus != (${words[@]} - 1) )); then
            Target $word_focus
        fi
    fi

    tput cup $player_row $player_col
    printf "${sprite[ship]}"
}

Game_Loop() {
    local           \
        draw_exit   \
        hit         \
        key         \
        key1        \
        key2        \
        key3        \
        lower_word  \
        post_time   \
        pre_time    \
        unpause

    while true; do
        # If there are no words left, level up
        if (( ${#words[@]} == 0 )); then
            (( level++ ))
            tput cup 19 21
            printf "\e[1mLEVEL $level\e[0m"
            sleep 2
            tput cup 19 21
            printf "         "
            # Clear input buffer
            read -t 0.0001 -n 10000
            # Increase speed
            (( speed = (60 - ($level * 2)) ))
            (( $speed < 12 )) && speed=12
            Load_Enemies false
        fi
        # Draw enemies if loop was not interrupted with key input
        if $draw_enemies; then
            Draw_All
            draw_exit=$?
            (( $draw_exit > 1 )) && return $draw_exit
        fi
        pre_time=$( date '+%2N' | sed 's/^0//' )
        IFS= read -rsn1 -t0.$(( $speed - $time_taken )) key1
        read_pid=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $read_pid != 142 )); then
            hit=false
            # If enter or space is pressed, consider as hit and ignore
            if [ -z "$key1" ] || [[ "$key1" == " " ]]; then
                hit=true
            # If escape is pressed
            elif [[ "$key1" == $'\e' ]]; then
                if [ -z "$key2" ]; then
                    # Basic pause screen
                    tput cup 18 21
                    printf '\e[1m PAUSE \e[0m'
                    while read -rsn1 unpause; do
                        [[ "$unpause" == $'\e' ]] && break
                    done
                    tput cup 18 21
                    printf '%7s' ''
                fi
                hit=true
            elif [[ "$key1" =~ ^[a-zA-Z0-9]$ ]]; then
                key=$( tr 'A-Z' 'a-z' <<< "$key1" )
                if [ -z "$word_focus" ] && ! $hit; then
                    # Loop through all words on screen
                    for (( w = 0; w < ${#words[@]}; w++ )); do
                        if (( ${enemy_row[$w]} > 0 && ${enemy_row[$w]} < 35 )); then
                            lower_word=$( tr 'A-Z' 'a-z' <<< "${words[$w]}" )
                            # True if key pressed matches the first character
                            if [[ "$key" == "${lower_word:0:1}" ]]; then
                                hit=true
                                match=1
                                Target "$w"
                                stun=$word_focus
                                Shoot true $word_focus
                                break
                            fi
                        fi
                    done
                elif [ -n "$word_focus" ]; then
                    lower_word=$( tr 'A-Z' 'a-z' <<< "${words[$word_focus]}" )
                    if [[ "$key" == "${lower_word:$match:1}" ]]; then
                        hit=true
                        (( match++ ))
                        stun=$word_focus
                        Shoot false $word_focus
                    fi
                fi
            fi
            # If no hit is made, reset score
            $hit || Score_Modifier false
        fi
        post_time=$( date '+%2N' | sed 's/^0//' )
        (( $post_time < $pre_time )) && (( post_time += 100 ))
        if (( $time_taken )); then
            (( time_taken += ($post_time - $pre_time) ))
        else
            (( time_taken = ($post_time - $pre_time) ))
        fi
        if (( $time_taken < $speed )); then
            draw_enemies=false
        else
            draw_enemies=true
            time_taken=0
        fi
        unset key1 key2 key3
    done
}

# Set blank global variables to allow restarting
New_Game() {
    Clear_Map 37
    # Build wall at full width of the playable area
    wall_log=( $( printf '%.0s4 ' {0..46} ) )
    tput cup 36 1
    printf "%.0s${sprite[wall4]}" {0..46}
    # Set level to 0 and then instantly level up
    level=0
    # Player starting position
    player_row=35
    player_col=24
    # Draw enemies upon load
    draw_enemies=true
    # Reset time
    time_taken=0
    score=0
    if $in_cli; then
        # If Debian
        if hash apt 2>/dev/null; then
            # Default, red, yellow, green, turquoise, blue, purple, pink
            score_colours=(
                '\e[0m'
                '\e[38;5;160m'
                '\e[38;5;178m'
                '\e[38;5;76m'
                '\e[38;5;43m'
                '\e[38;5;27m'
                '\e[38;5;128m'
                '\e[38;5;205m'
            )
        # If Red Hat, colours have to be simplified
        elif hash yum 2>/dev/null; then
            # Default, red, orange, green, turquoise, blue, purple, white
            score_colours=(
                '\e[0m'
                '\e[31m'
                '\e[33m'
                '\e[32m'
                '\e[36m'
                '\e[34m'
                '\e[35m'
                '\e[97m'
            )
        fi
    else
        # Default, red, orange, yellow, green, turquoise, blue, purple
        score_colours=(
            '\e[0m'
            '\e[38;5;160m'
            '\e[38;5;166m'
            '\e[38;5;178m'
            '\e[38;5;76m'
            '\e[38;5;43m'
            '\e[38;5;27m'
            '\e[38;5;128m'
        )
    fi
    if $in_cli; then
        score_colours=( ${score_colours[@]:0:2} ${score_colours[@]:3} )
        score_colours+=( '\e[38;5;205m' )
    fi
    score=0
    Score_Modifier false
    Game_Loop
    return $?
}

####    Menu system    ####

: <<'Text_Entry_Doc'
    @Param      int     1
        Row to read input
    @Param      int     2
        Col to read input
    @Param      int     3
        Max length of input
    @Param      string  4
        Backspace replacement character
    @Param      string  5
        Variable name to overwrite
Text_Entry_Doc

Text_Entry() {
    local               \
        input_string    \
        key
    tput cup $1 $2
    # Turn echo back on for text input
    stty echo
    tput cvvis
    printf '\e[1m'
    read -n 10000 -t 0.0001 discard
    # Clear IFS to avoid whitespace treated as null
    while IFS= read -sn1 key; do
        if [ -z "$key" ]; then
            if (( ${#input_string} )); then
                break
            else
                tput cup $1 $2
            fi
        # If backspace character is pressed, remove last entry
        elif [[ "$key" == $'\177' ]]; then
            if (( ${#input_string} )); then
                printf "\b$4\b"
                input_string=${input_string:0: -1}
            fi
        elif (( ${#input_string} > $3 )); then
            continue
        elif [[ "$key" == [\ _] ]]; then
            # Replace spaces with underscores
            printf '_'
            input_string+="_"
        elif [[ "$key" == [[:punct:]] ]]; then
            # Disallow punctuation
            continue
        elif [[ "$key" == [[:alnum:]] ]]; then
            printf "$key"
            input_string+="$key"
        fi
    done
    eval "$5"="$input_string"
    printf '\e[0m'
    tput civis
    stty -echo
}

: <<'Print_Score_Doc'
    @Param      int     1
        Row to print next highscore
    @Param      int     2
        Number associated to the highscore
    @Param      string  3
        Highscore username
    @Param      string  4
        Highscore value
Print_Score_Doc

Print_Score() {
    local           \
        b           \
        hr_score    \
        pad         \
        spacer
    # Make the score human readable
    for (( b = ${#4}; b > 0; b-- )); do
        (( ($b < ${#4}) && ($b % 3 == 0) )) && hr_score+=","
        hr_score+="${4: -b:1}"
    done
    tput cup $1 6
    (( pad = (33 - (${#3} + ${#hr_score})) ))
    eval printf -v spacer '%.0s.' {1..$pad}
    printf '%-3s%s%s%s\e[0m' "$2" "$3" "$spacer" "$hr_score"
}

Show_Scores() {
    local               \
        hs_name         \
        key             \
        line_index      \
        ln              \
        next_score      \
        num_scores      \
        score_ln        \
        score_max       \
        score_row       \
        usernames=()    \
        userscores=()

    Clear_Map 38
    tput cup 3 19
    printf '\e[1mHIGHSCORES\e[0m'

    if [ -s "$text_file" ]; then
        hs_log="$log_dir/highscores/$( basename "$text_file" | tr [A-Z] [a-z] )"
        hs_log="${hs_log%\.*}.shs"
    else
        hs_log="$log_dir/highscores/default.shs"
    fi
    touch "$hs_log"

    hs_name=$( basename "$hs_log" .shs )
    tput cup 5 $(( 24 - (${#hs_name} / 2) ))
    printf "${hs_name^}"

    num_scores=$( wc -l < "$hs_log" )
    for (( ln = 0; ln < $num_scores; ln++ )); do
        (( line_index = ($ln + 1) ))
        score_ln=$( sed -n "${line_index}p" "$hs_log" )
        userscores[$ln]=${score_ln/*\,/}
        usernames[$ln]=${score_ln/\,*/}
    done

    score_row=8
    (( score_max = (${#userscores[@]} < 21 ? ${#userscores[@]} : 20) ))
    for (( next_score = 0; next_score < $score_max; next_score++ )); do
        tput cup $score_row 6
        Print_Score $score_row $(( $next_score + 1 )) \
            "${usernames[$next_score]}" ${userscores[$next_score]}
        (( score_row++ ))
    done

    tput cup 30 22
    printf '\e[7mBACK\e[0m'
    while IFS= read -n1 key; do
        [ -z "$key" ] && return
    done
}

Sub_Menu() {
    local                   \
        allow_change=true   \
        CHEXT               \
        cycle_max=4         \
        EXTB                \
        HIDDEN              \
        key1                \
        key2                \
        key3                \
        sm_choose=4

    if ${settings[1]}; then
        allow_change=false
        cycle_max=3
        sm_choose=3
    fi
    Clear_List
    tput cup 4 8
    printf '\e[1m             OPTIONS         \e[0m'
    while true; do
        case $sm_choose in
            *)  if $allow_change; then
                    CHEXT='Change Extension'
                else
                    CHEXT='\e[2mChange Extension\e[0m'
                fi
                EXTB='Ignore Extension'
                HIDDEN='Show Hidden Files'
                SAVE='Save Settings'
                RETURN='Main Menu';;&
            4)  CHEXT="\e[7m$CHEXT\e[0m";;
            3)  EXTB="\e[7m$EXTB\e[0m";;
            2)  HIDDEN="\e[7m$HIDDEN\e[0m";;
            1)  SAVE="\e[7m$SAVE\e[0m";;
            0)  RETURN="\e[7m$RETURN\e[0m";;
        esac

        tput cup 12 8
        printf "$CHEXT"
        tput cup 12 34
        printf "${settings[0]}"
        tput cup 15 8
        printf "$EXTB"
        tput cup 15 34
        printf "%-5s" "${settings[1]}"
        tput cup 18 8
        printf "$HIDDEN"
        tput cup 18 34
        printf "%-5s" "${settings[2]}"
        tput cup 31 18
        printf "$SAVE"
        tput cup 33 20
        printf "$RETURN"

        IFS= read -rsn1 key1
        read -rsn1 -t 0.0001 key2
        read -rsn1 -t 0.0001 key3

        if [[ "$key3" == "A" ]]; then
            (( $sm_choose == $cycle_max ? sm_choose = 0 : sm_choose++ ))
        elif [[ "$key3" == "B" ]]; then
            (( $sm_choose == 0 ? sm_choose = $cycle_max : sm_choose-- ))
        fi

        if [ -z "$key1" ]; then
            case $sm_choose in
                4)  settings[0]=""
                    tput cup 12 34
                    printf "%6s"
                    Text_Entry 12 34 6 " " "settings[0]";;
                3)  if ${settings[1]}; then
                        cycle_max=4
                        allow_change=true
                        settings[1]=false
                    else
                        cycle_max=3
                        allow_change=false
                        settings[1]=true
                    fi;;
                2)  ${settings[2]} && settings[2]=false || settings[2]=true;;
                1)  printf "%s,%s,%s" "${settings[@]}" > $log_dir/settings.txt;;
                0)  return 1;; # Return to main menu
            esac
        fi

        if [[ "$key1" == $'\e' ]] && [ -z "$key2" -a -z "$key3" ]; then
            break
        fi
        unset key1 key2 key3
    done
    Clear_List
    redraw_title=true
    change_dir=true
    return 0
}

# Similar to Clear_Map in function, but localised to the file structure
Clear_List() {
    local clean
    for (( clean = 6; $clean < 38; clean++ )); do
        tput cup $clean 8
        printf '%33s' ''
    done
}

: <<'Check_File_Exists_Doc'
    @Param      string  1
        File to check
Check_File_Exists_Doc

Check_File_Exists() {
    local           \
        check_file  \
        default_dir

    for default_dir in ${diff_select[@]}; do
        dir_lower=$( tr '[A-Z]' '[a-z]' <<< "$default_dir" )
        check_file="$lib_dir/texts/$dir_lower/$( basename "$1" )"
        if [ -s "$check_file" ]; then
            chosen_item="$check_file"
            return 1
        fi
    done
    return 0
}

: <<'Preview_File_Doc'
    @Param      string  1
        File to be viewed
Preview_File_Doc

Preview_File() {
    local           \
        file_line   \
        preview_row

    Clear_Map 38 4
    file_name=$( basename $1 )
    tput cup 4 $(( 24 - (${#file_name} / 2) ))
    printf "$file_name"
    tput cup 6 21
    printf "\e[1mPREVIEW\e[0m"
    tput cup 36 22
    printf "\e[7mBACK\e[0m"
    preview_row=8

    while read file_line; do
        tput cup $preview_row 8
        printf "${file_line:0:32}"
        (( preview_row++ ))
    done < <( head -n25 "$1" )
    read -s

    redraw_title=true
    Clear_Map 38 4
}

: <<'File_Select_Doc'
    @Param      string  1
        Starting directory (optional)
    @Param      bool    2
        True if parent allowed (optional)
    @Param      bool    3
        True if settings allowed (optional)
File_Select_Doc

File_Select() {
    Clear_List
    unset text_file
    local                                                       \
        allow_navigate=true                                     \
        allow_options=true                                      \
        bkey1                                                   \
        bkey2                                                   \
        bkey3                                                   \
        change_dir=true                                         \
        char_lower                                              \
        char_upper                                              \
        contents                                                \
        current_directory=~                                     \
        ext_char                                                \
        ext_grep                                                \
        file_name                                               \
        file_row                                                \
        highlighted_line                                        \
        item                                                    \
        item_colour                                             \
        item_limit                                              \
        item_selected                                           \
        key1                                                    \
        key2                                                    \
        key3                                                    \
        line_count                                              \
        max_items                                               \
        new_file_name                                           \
        new_primary_index                                       \
        parent_colour                                           \
        parent_index                                            \
        primary_index=1                                         \
        redraw_title=true                                       \
        save_file                                               \
        settings=( $( tr ',' ' ' < "$log_dir/settings.txt" ) )  \
        show_hidden                                             \
        trail

    if [ -n "$1" -a -d "$1" ]; then
        current_directory="$1"
    fi
    if [ -n "$2" ]; then
        allow_navigate=$2
    fi
    if [ -n "$3" ]; then
        allow_options=$3
    fi

    while true; do
        if $redraw_title && $allow_options; then
            tput cup 4 8
            printf '\e[1mPress escape for more options\e[0m'
            redraw_title=false
        fi

        # If in a new directory, clear the screen and update the variables
        if $change_dir; then
            [ -n "$file_row" ] && Clear_List
            if ${settings[2]}; then
                show_hidden='-A'
            else
                show_hidden=''
            fi
            contents="$( ls -p $show_hidden "$current_directory" 2>/dev/null )"

            # Set extension to search with
            if ${settings[1]}; then
                ext_grep=""
            else
                ext_grep="(\.${settings[0]}|\/)$"
            fi

            # Pull directory contents
            contents="$(
                ls -p $show_hidden "$current_directory" 2>/dev/null | \
                grep -Pi "$ext_grep"
            )"

            # Always highlight first entry, if exists, not parent
            if [ -z "$contents" ]; then
                item_selected=0
                highlighted_line=0
                max_items=0
            else
                item_selected=1
                highlighted_line=1
                max_items=$( wc -l <<< "$contents" )
            fi
            primary_index=1
            change_dir=false
        fi

        # If there is a parent, then show "../"
        if [[ "$current_directory" =~ /.+ ]] && $allow_navigate; then
            tput cup 6 8
            parent_colour="\e[1;34m"
            (( $item_selected )) || parent_colour="\e[7;1;34m"
            printf "$parent_colour..\e[0m/"
            parent_index=0
        else
            # If not, disallow highlighting by setting max scroll height
            parent_index=1
        fi

        file_row=7
        line_count=1
        while read -r item; do
            # If directory (cannot test -d due to relative path)
            if [[ "$item" =~ .*/$ ]]; then
                item=${item:0:-1}
                item_colour="\e[1;34m"
                trail="/"
            else
                item_colour=""
                trail=""
            fi
            tput cup $(( file_row++ )) 8
            (( $highlighted_line == $line_count )) && printf "\e[7m"
            # Allow only 32 items on screen up to 33 characters
            (( item_limit = (${#item} > 32 ? 32 : ${#item}) ))
            (( line_limit = ($item_limit == 33 ? 0 : (33 - $item_limit)) ))
            printf "$item_colour%-${item_limit}s\e[0m%-${line_limit}s" "${item:0:32}" "$trail"
            (( line_count++ ))
        done < <( sed -n "${primary_index},$(( $primary_index + 28 ))p" "$contents" )

        # Take key input
        IFS= read -rsn1 key1
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If backspace then return to previous menu
        if [[ "$key1" == $'\177' ]]; then
            return 0
        fi

        case $key3 in
            A)  if (( $item_selected == $parent_index )); then
                    item_selected=$max_items
                    highlighted_line=$max_items
                else
                    (( item_selected-- ))
                    (( highlighted_line-- ))
                fi;; # Up
            B)  if (( $item_selected == $max_items )); then
                    item_selected=$parent_index
                    highlighted_line=$parent_index
                else
                    (( item_selected++ ))
                    (( highlighted_line++ ))
                fi;; # Down
            D)  if (( $parent_index == 0 )); then
                    unset key1
                    item_selected=0
                    highlighted_line=0
                fi;; # Left: set up to go to parent
        esac

        # Calculate where in the list to start printing
        if (( $max_items > 29 )); then
            if (( $item_selected < 15 )); then
                new_primary_index=1
            elif (( $item_selected < ($max_items - 14) )); then
                (( new_primary_index = ($item_selected - 14) ))
            elif (( $item_selected <= $max_items )); then
                (( new_primary_index = ($max_items - 28) ))
            fi
            if (( $new_primary_index != $primary_index )); then
                if (( ($new_primary_index > $primary_index) && ($highlighted_line != $max_items) )); then
                    (( highlighted_line-- ))
                elif (( ($new_primary_index < $primary_index) && ($highlighted_line != 0) )); then
                    (( highlighted_line++ ))
                fi
                primary_index=$new_primary_index
            fi
        fi

        if (( ($highlighted_line == $max_items) && ($max_items > 29) )); then
            highlighted_line=29
        fi

        # If user presses enter or the right arrow key
        if [ -z "$key1" ] || [[ "$key3" == "C" ]]; then
            if (( $item_selected )); then
                chosen_item="$current_directory/$( sed -n "${item_selected}p" <<< "$contents" )"
                # If chosen item is a directory, then open it
                if [[ "$chosen_item" =~ .*/$ ]]; then
                    # Strip trailing slash
                    current_directory="${chosen_item:0: -1}"
                    change_dir=true
                elif [ -s "$chosen_item" -a -z "$key1" ]; then
                    # If in custom file select and does not already exist
                    if $allow_navigate; then
                        new_file_name="$( basename "${chosen_item%.*}" | tr ' ' '_' | sed 's/^\.//' ).txt"
                        Check_File_Exists "$new_file_name"
                        if (( ! $? )); then
                            Clear_Map 38 4
                            file_name=$( basename "$chosen_item" )
                            tput cup 4 $(( 24 - (${#file_name} / 2) ))
                            printf "$file_name"
                            tput cup 7 8
                            printf "Would you like to save this file"
                            tput cup 8 13
                            printf "to the custom folder?"
                            save_file=1
                            while true; do
                                tput cup 10 20
                                if (( $save_file )); then
                                    printf "\e[7mYES\e[0m    NO"
                                else
                                    printf "YES    \e[7mNO\e[0m"
                                fi

                                IFS= read -rsn1 bkey1
                                read -rsn1 -t0.0001 bkey2
                                read -rsn1 -t0.0001 bkey3
                                [[ "$bkey3" == [CD] ]] && (( save_file ^= 1 ))

                                if [ -z "$bkey1" ]; then
                                    if (( $save_file )); then
                                        # Format filename to a text file
                                        text_file="$lib_dir/texts/custom/$new_file_name"
                                    else
                                        text_file="/tmp/$new_file_name"
                                    fi
                                    # Format text file to allow each line to be built into an array
                                    tr '.' '\n' < "$chosen_item" | \
                                        sed -r 's/(-|—)/ /;s/[^[:alnum:]| ]//g;/^ *$/d' >| "$text_file"
                                    # Remove leading and trailing whitespace
                                    sed -i 's/^[[:space:]]*//;s/[[:space:]]*$//' "$text_file"
                                    return 1
                                fi
                                unset bkey1 bkey2 bkey3
                            done
                        else
                            text_file="$chosen_item"
                            return 1
                        fi
                    # If in easy, medium or hard
                    else
                        text_file="$chosen_item"
                        return 1
                    fi
                fi
            elif (( $parent_index == 0 )); then
                # Go to parent
                current_directory="$( dirname "$current_directory" )"
                change_dir=true
            fi
        fi

        # If space, show preview
        if [[ "$key1" == " " ]]; then
            Preview_File "$current_directory/$( sed -n "${item_selected}p" <<< "$contents" )"
        fi

        # If escapse, show settings
        if [[ "$key1" == $'\e' ]]; then
            if [ -z "$key2" -a -z "$key3" ] && $allow_options; then
                Sub_Menu
                (( $? )) && return 1
            # If navigation is allowed, go to ~ on home key press
            elif $allow_navigate && [[ "$key3" = "H" ]]; then
                current_directory=~
                change_dir=true
            fi
        fi
        unset key1 key2 key3
    done
}

File_Menu() {
    local                           \
        diff_choose=0               \
        diff_cols=( 4 15 28 39 )    \
        diff_index                  \
        diff_select                 \
        dir_lower                   \
        key1                        \
        key2                        \
        key3                        \

    Clear_Map 38
    tput cup 0 11
    printf "┬────────────┬──────────┬"
    tput cup 1 11
    printf "│            │          │"
    tput cup 2 0
    printf "├──────────┴────────────┴──────────┴────────────┤"

    while true; do
        diff_select=(
            'EASY'
            'MEDIUM'
            'HARD'
            'CUSTOM'
        )

        for (( diff_index = 0; diff_index < ${#diff_cols[@]}; diff_index++ )); do
            tput cup 1 ${diff_cols[$diff_index]}
            if (( $diff_index == $diff_choose )); then
                printf "\e[7m${diff_select[$diff_choose]}\e[0m"
            else
                printf "${diff_select[$diff_index]}"
            fi
        done

        IFS= read -rsn1 key1
        read -rsn1 -t 0.0001 key2
        read -rsn1 -t 0.0001 key3

        if [[ "$key3" == "D" ]]; then
            (( $diff_choose == 0 ? diff_choose = 3 : diff_choose++ ))
        elif [[ "$key3" == "C" ]]; then
            (( $diff_choose == 3 ? diff_choose = 0 : diff_choose-- ))
        fi
        if [ -z "$key1" ]; then
            Clear_Map 38 3
            # Print menu again but fade non-chosen
            for (( diff_index = 0; diff_index < ${#diff_cols[@]}; diff_index++ )); do
                tput cup 1 ${diff_cols[$diff_index]}
                if (( $diff_index != $diff_choose )); then
                    printf "\e[2m${diff_select[$diff_index]}\e[0m"
                else
                    printf "\e[1m${diff_select[$diff_choose]}"
                fi
            done

            dir_lower=$( tr '[A-Z]' '[a-z]' <<< "${diff_select[$diff_choose]}" )
            if (( $diff_choose == 3 )); then
                File_Select "$lib_dir/texts/$dir_lower"
                (( $? )) && return
            else
                File_Select "$lib_dir/texts/$dir_lower" false false
                (( $? )) && return
            fi
        fi

        if [[ "$key1" == $'\177' ]] && [ -z "$key2" -a -z "$key3" ]; then
            return
        fi
        unset key1 key2 key3
    done
}

: <<'Clear_Map_Doc'
    @Param      int     1
        Amount of rows to clear
    @Param      int     2
        Starting row (optional)
Clear_Map_Doc

Clear_Map() {
    local               \
        clear_row       \
        clear_start=1

    if [ -n "$2" ]; then
        clear_start=$2
        tput cup $2 0
    else
        # Clear the screen
        if $in_tty; then
            printf "\033[2J\033[0;0H"
        else
            tput reset
        fi
        printf '┌───────────────────────────────────────────────┐\n'
    fi
    for (( clear_row = $clear_start; clear_row < $1; clear_row++ )); do
        printf '│                                               │\n'
    done
    printf '└───────────────────────────────────────────────┘'
    tput civis
}

function Main_Menu {
    local controls_box
    # Clear screen
    tput clear
    # Display the main menu
    Clear_Map 38
    tput cup 2 18
    printf "Ben  Pitman's"
    tput cup 4 14
    printf '\e[1mS U P E R S C R I P T\e[0m'
    tput cup 8 18
    printf '\e[1mGAME CONTROLS\e[0m'
    tput cup 10 11
    printf 'ESC          -      Pause'
    tput cup 11 11
    printf 'Ctrl-C       -       Quit'
    tput cup 14 18
    printf '\e[1mMENU CONTROLS\e[0m'
    tput cup 16 11
    printf 'arrow keys   -   navigate'
    tput cup 17 11
    printf 'ESC          -    options'
    tput cup 18 11
    printf 'backspace    -       back'
    tput cup 19 11
    printf 'space        -    preview'
    tput cup 20 11
    printf 'home         -   go to ~/'
}

# Populate sprite array
declare -A sprite
Load_Sprites

stty -echo # Disable echo
hs_log="$log_dir/highscores/default.shs"
touch "$hs_log" # Create score log if doesn't exist
lib_dir="/usr/local/lib/superscript"
tput civis  # Disable cursor blinker
selected=3 # Default menu select

# Selection menu outside a function to refresh the main upon return
Main_Menu
while true; do
    case $selected in
        *)  START='START'
            TEXT='CHOOSE TEXT'
            SCORES='HIGH SCORES'
            QUIT='QUIT';;&
        3)  START="\e[7m$START\e[0m";;
        2)  TEXT="\e[7m$TEXT\e[0m";;
        1)  SCORES="\e[7m$SCORES\e[0m";;
        0)  QUIT="\e[7m$QUIT\e[0m";;
    esac

    tput cup 24 22
    printf "$START"
    tput cup 26 19
    printf "$TEXT"
    tput cup 28 19
    printf "$SCORES"
    tput cup 30 22
    printf "$QUIT"

    if [ -s "$text_file" ]; then
        hs_log="$log_dir/highscores/$( basename "$text_file" | tr [A-Z] [a-z] )"
        hs_log="${hs_log%\.*}.shs"
    else
        hs_log="$log_dir/highscores/default.shs"
    fi
    touch "$hs_log"

    hs_name=$( basename "$hs_log" .shs | tr '_' ' ' )
    tput cup 34 $(( 24 - (${#hs_name} / 2) ))
    printf "\e[4m${hs_name^}\e[0m"
    tput cup 35 16
    printf 'Text file chosen'

    # Get user input and control keys
    IFS= read -rsn1 key1
    read -rsn1 -t 0.0001 key2
    read -rsn1 -t 0.0001 key3

    if [[ "$key3" == "A" ]]; then
        (( $selected == 3 ? selected = 0 : selected++ )) # Up
    elif [[ "$key3" == "B" ]]; then
        (( $selected == 0 ? selected = 3 : selected-- )) # Down
    fi

    if [ -z "$key1" ]; then
        case $selected in
            3)  while true; do
                    New_Game
                    (( $? == 3 )) && break
                done;;
            2)  File_Menu;;
            1)  Show_Scores false;;
            0)  exit;;
        esac
        Main_Menu
    fi

    unset key1 key2 key3
done
